<!DOCTYPE html>
<html lang='es'>
<head>
<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0'>
<title>ColorAid PRO</title>
<style>
/* -------------------- Estilos Generales -------------------- */
body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: #f2f2f2;
    text-align: center;
    padding-bottom: 30px; /* Espacio al final */
}

header {
    background: #005bbb;
    color: white;
    padding: 15px;
    font-size: 22px;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    position: sticky;
    top: 0;
    z-index: 50;
}

header span {
    margin-right: 15px;
    cursor: pointer;
}

h2 {
    color: #005bbb;
    border-bottom: 2px solid #005bbb;
    padding-bottom: 5px;
    width: 90%;
    max-width: 400px;
    margin: 20px auto 15px;
}

button {
    padding: 12px;
    margin: 8px;
    width: 90%;
    max-width: 300px;
    border: none;
    border-radius: 10px;
    font-size: 16px;
    background: #007bff;
    color: white;
    cursor: pointer;
    transition: background-color 0.2s;
}

button:hover {
    background: #0056b3;
}

/* -------------------- Indicador de Estado -------------------- */
#statusIndicator {
    background-color: #e9ecef;
    padding: 8px;
    margin: 0 auto 10px;
    width: 90%;
    max-width: 400px;
    border-radius: 5px;
    color: #333;
    font-weight: bold;
    font-size: 14px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}

/* -------------------- Menú Lateral -------------------- */
#menu {
    position: fixed;
    left: 0;
    top: 0;
    width: 70%;
    max-width: 250px;
    height: 100%;
    background: white;
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
    transform: translateX(-100%);
    transition: 0.3s;
    padding: 20px;
    z-index: 1000;
    text-align: left;
    overflow-y: auto;
}

#menu.open {
    transform: translateX(0);
}

.mode-btn {
    background: white;
    border-left: 6px solid #007bff;
    border-radius: 5px;
    padding: 12px;
    margin: 5px 0;
    cursor: pointer;
    text-align: left;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    transition: background-color 0.2s;
}

.mode-btn:hover {
    background: #f0f0f0;
}

/* -------------------- Sección de Imagen Cargada -------------------- */
#imageContainer {
    margin: 10px auto;
    max-width: 380px;
    width: 90%;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

canvas#imageCanvas {
    background: #ddd;
    display: block;
    width: 100%;
    height: auto;
}

#filterControls {
    margin: 10px auto 20px;
    padding: 10px;
    background: #e9ecef;
    border-radius: 5px;
    width: 90%;
    max-width: 380px;
}

#filterControls button {
    width: auto;
    margin: 5px;
    padding: 8px 15px;
    font-size: 14px;
    background: #28a745;
}

#filterControls button:hover {
    background: #1e7e34;
}

/* -------------------- Sección de Cámara (más pequeña) -------------------- */
#videoContainer {
    margin: 10px auto;
    max-width: 320px; /* Tamaño más pequeño para la cámara */
    width: 90%;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

#video, #videoCanvas {
    width: 100%;
    height: auto;
    display: block;
}

#cameraSelect {
    margin-bottom: 10px;
    padding: 10px;
    border-radius: 5px;
    border: 1px solid #ccc;
}

/* -------------------- Sección de Test -------------------- */
#testArea {
    width: 90%;
    max-width: 380px;
    margin: 20px auto;
    padding: 15px;
    border: 1px dashed #ccc;
    border-radius: 8px;
}

canvas#testCanvas {
    max-width: 100%;
    border: 1px solid #ddd;
    border-radius: 5px;
}

#testAnswer {
    padding: 10px;
    width: 120px;
    margin-top: 10px;
    border-radius: 5px;
    border: 1px solid #ccc;
}
</style>
</head>
<body>

<header><span onclick="toggleMenu()">☰</span> ColorAid PRO</header>

<div id="statusIndicator">Filtro Activo: Ninguno</div>

<div id="menu">
    <h3>Menú de Filtros</h3>
    <div class="mode-btn" onclick="setFilter('deuteranopia')">Deuteranopia (Rojo-Verde)</div>
    <div class="mode-btn" onclick="setFilter('protanopia')">Protanopia (Rojo-Verde)</div>
    <div class="mode-btn" onclick="setFilter('tritanopia')">Tritanopia (Azul-Amarillo)</div>
    <div class="mode-btn" onclick="setFilter(null)">Filtro Original / Desactivar</div>
    <hr>
    <h3>Controles de Cámara</h3>
    <button onclick="startCamera()">Abrir Cámara</button>
    <button onclick="stopCamera()">Detener Cámara</button>
    <hr>
    <h3>Test</h3>
    <button onclick="startTest()">Test Ishihara</button>
    <button onclick="toggleMenu()">Cerrar Menú</button>
</div>

<h2>Subir imagen</h2>
<input type="file" id="imageInput" accept="image/*">

<div id="imageContainer">
    <canvas id="imageCanvas"></canvas>
</div>

<div id="filterControls" style="display:none;">
    <h4>Aplicar Filtro a Imagen:</h4>
    <button onclick="applyCurrentFilterToImage()">Aplicar Filtro Actual</button>
    <button onclick="resetImage()">Restaurar Imagen</button>
</div>


<h2>Cámara</h2>
<select id="cameraSelect"></select>
<div id="videoContainer">
    <video id="video" autoplay playsinline style="display:none;"></video>
    <canvas id="videoCanvas" style="display:none;"></canvas>
</div>


<h2>Test Ishihara</h2>
<div id="testArea" style="display:none;">
    <canvas id="testCanvas"></canvas>
    <input id="testAnswer" type="number" placeholder="Número" style="padding:10px;width:120px;margin-top:10px;">
    <button onclick="submitAnswer()">Responder</button>
</div>
<div id="testResult"></div>

<script>
// -------------------- Lógica de la Aplicación --------------------

function toggleMenu() {
    document.getElementById('menu').classList.toggle('open');
}

// Variables Globales
let selectedMatrix = null;
let originalImageData = null; 

const matrices = {
    // Matriz de corrección para Deuteranopia
    deuteranopia: [
        [0.625, 0.375, 0],
        [0.7, 0.3, 0],
        [0, 0.3, 0.7]
    ],
    // Matriz de corrección para Protanopia
    protanopia: [
        [0.567, 0.433, 0],
        [0.558, 0.442, 0],
        [0, 0.242, 0.758]
    ],
    // Matriz de corrección para Tritanopia
    tritanopia: [
        [0.95, 0.05, 0],
        [0, 0.433, 0.567],
        [0, 0.475, 0.525]
    ]
};

const filterNames = {
    deuteranopia: "Deuteranopia",
    protanopia: "Protanopia",
    tritanopia: "Tritanopia",
    null: "Ninguno"
};

// Elementos DOM
const imgCanvas = document.getElementById("imageCanvas");
const imgCtx = imgCanvas.getContext("2d");
const statusIndicator = document.getElementById("statusIndicator");
const filterControls = document.getElementById('filterControls');
let originalImg = new Image();


/**
 * Actualiza el indicador de filtro activo en la interfaz.
 */
function updateStatusIndicator(type) {
    const name = filterNames[type] || "Ninguno";
    statusIndicator.textContent = "Filtro Activo: " + name;
}

/**
 * Establece el filtro seleccionado y actualiza el estado.
 */
function setFilter(type) {
    selectedMatrix = type ? matrices[type] : null;
    updateStatusIndicator(type);

    // Si hay una imagen cargada, mostramos los controles para aplicarlo
    if (originalImageData) {
        filterControls.style.display = 'block';
    }
}

/**
 * Aplica la matriz de filtro actual al lienzo dado.
 */
function applyMatrix(canvas, ctx) {
    if (!selectedMatrix) return;
    
    let img = ctx.getImageData(0, 0, canvas.width, canvas.height);
    let d = img.data;
    const m = selectedMatrix;
    
    for (let i = 0; i < d.length; i += 4) {
        let r = d[i],
            g = d[i + 1],
            b = d[i + 2];
        
        let nr = r * m[0][0] + g * m[0][1] + b * m[0][2];
        let ng = r * m[1][0] + g * m[1][1] + b * m[1][2];
        let nb = r * m[2][0] + g * m[2][1] + b * m[2][2];
        
        d[i] = Math.min(255, Math.max(0, Math.floor(nr))); 
        d[i + 1] = Math.min(255, Math.max(0, Math.floor(ng)));
        d[i + 2] = Math.min(255, Math.max(0, Math.floor(nb)));
    }
    ctx.putImageData(img, 0, 0);
}


// --- Lógica de Imagen Cargada ---

document.getElementById("imageInput").addEventListener("change", e => {
    let f = e.target.files[0];
    if (!f) return;
    
    let r = new FileReader();
    r.onload = v => {
        originalImg = new Image();
        originalImg.onload = () => {
            // Ajuste de tamaño base (se escala con CSS en el contenedor)
            const maxWidth = 800; 
            let ratio = originalImg.width > maxWidth ? maxWidth / originalImg.width : 1;
            
            imgCanvas.width = originalImg.width * ratio; 
            imgCanvas.height = originalImg.height * ratio;
            
            imgCtx.drawImage(originalImg, 0, 0, imgCanvas.width, imgCanvas.height);
            
            // Guardar los datos de la imagen original (sin filtro)
            originalImageData = imgCtx.getImageData(0, 0, imgCanvas.width, imgCanvas.height);
            filterControls.style.display = 'block';

            // Si hay un filtro seleccionado, aplicarlo inmediatamente
            if (selectedMatrix) applyCurrentFilterToImage();
        };
        originalImg.src = v.target.result;
    };
    r.readAsDataURL(f);
});

/**
 * Aplica el filtro seleccionado a la imagen cargada (sobre la base original).
 */
function applyCurrentFilterToImage() {
    if (!originalImageData) {
        alert("Por favor, carga una imagen primero.");
        return;
    }
    
    // 1. Restaurar la imagen a su estado original (copia limpia)
    imgCtx.putImageData(originalImageData, 0, 0);
    
    // 2. Aplicar el filtro si hay uno seleccionado
    if (selectedMatrix) {
        applyMatrix(imgCanvas, imgCtx);
    }
}

/**
 * Restaura la imagen cargada a su estado original.
 */
function resetImage() {
    if (originalImageData) {
        imgCtx.putImageData(originalImageData, 0, 0);
        // Opcional: Quitar el filtro actual también
        setFilter(null); 
    }
}


// --- Lógica de la Cámara (más pequeña y optimizada) ---

let stream = null;
const video = document.getElementById("video");
const videoCanvas = document.getElementById("videoCanvas");
const vCtx = videoCanvas.getContext("2d");

async function startCamera() {
    try {
        let devices = await navigator.mediaDevices.enumerateDevices();
        let select = document.getElementById("cameraSelect");
        select.innerHTML = "";
        
        devices.filter(d => d.kind === "videoinput").forEach(d => {
            let opt = document.createElement("option");
            opt.value = d.deviceId;
            opt.textContent = d.label || "Cámara Desconocida";
            select.appendChild(opt);
        });
        
        let id = select.value;
        if (!id) {
            alert("No se encontraron cámaras de video.");
            return;
        }

        // Constraints: Solicitamos una resolución base más pequeña para rendimiento
        const constraints = {
            video: {
                deviceId: id,
                width: { ideal: 640 }, 
                height: { ideal: 480 }
            }
        };

        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        video.style.display = "none";
        videoCanvas.style.display = "block";
        
        video.onloadedmetadata = () => {
            // Sincronizamos el tamaño del canvas con la resolución real del stream
            videoCanvas.width = video.videoWidth; 
            videoCanvas.height = video.videoHeight;
            requestAnimationFrame(loopCamera);
        };
        
    } catch (err) {
        console.error("Error al acceder a la cámara:", err);
        alert("Error al acceder a la cámara. Asegúrate de tener permisos.");
    }
}

function loopCamera() {
    if (!stream) return;
    
    // 1. Dibujar el frame del video en el canvas
    vCtx.drawImage(video, 0, 0, videoCanvas.width, videoCanvas.height);
    
    // 2. Aplicar el filtro si está seleccionado
    if (selectedMatrix) {
        applyMatrix(videoCanvas, vCtx);
    }
    
    // 3. Repetir para el siguiente frame
    requestAnimationFrame(loopCamera);
}

function stopCamera() {
    if (stream) {
        stream.getTracks().forEach(t => t.stop());
    }
    stream = null;
    video.style.display = "none";
    videoCanvas.style.display = "none";
    // Limpiar el canvas de video si es necesario
    vCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
}

// --- Lógica del Test Ishihara (Simulada) ---

// **NOTA:** Esto es un PLACEHOLDER. Debes implementar la lógica real del test.
// Por ejemplo, cargando imágenes de placas de Ishihara y verificando respuestas.
function startTest() {
    alert("Iniciando Test Ishihara (función de demostración). Debes implementar la carga de imágenes.");
    document.getElementById('testArea').style.display = 'block';
    // Lógica para cargar la primera placa en testCanvas.
}

function submitAnswer() {
    const answer = document.getElementById('testAnswer').value;
    if (answer) {
        document.getElementById('testResult').textContent = `Respuesta enviada: ${answer}. (Lógica de verificación pendiente de implementación).`;
    } else {
         document.getElementById('testResult').textContent = `Ingresa un número primero.`;
    }
}

// Inicializar el indicador de estado al cargar
document.addEventListener('DOMContentLoaded', () => {
    updateStatusIndicator(null);
});

</script>

</body>
</html>




